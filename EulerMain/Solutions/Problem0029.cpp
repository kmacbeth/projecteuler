#include "Problem0029.h"
#include "Libs\EulerMath.h"

namespace Euler {

    /**
     * PowerFactor constructor.
     *
     * @param a_Power The result of a^b.
     * @param a_Base  The base 'a'.
     * @param a_Exp   The exponent 'b'.
     */
    Problem29::PowerFactor::PowerFactor(uint32_t a_Power, uint32_t a_Exp) :
        m_Power(a_Power),
        m_Exp(a_Exp)
    {
    }

    /**
     * Problem: Distinct powers
     *
     * Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
     *
     * 2**2=4,  2**3=8,   2**4=16,  2**5=32
     * 3**2=9,  3**3=27,  3**4=81,  3**5=243
     * 4**2=16, 4**3=64,  4**4=256, 4**5=1024
     * 5**2=25, 5**3=125, 5**4=625, 5**5=3125
     * If they are then placed in numerical order, with any repeats removed, we
     * get the following sequence of 15 distinct terms:
     *
     *   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
     *
     * How many distinct terms are in the sequence generated by a**b for
     * 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
     */
    void Problem29::Solve()
    {
        // We need to find the number of duplicate and subtract it from the total.
        const uint32_t kLowerBound = 2;
        const uint32_t kUpperBound = 100;
        const uint32_t kMaxTerms = (kUpperBound - kLowerBound + 1) *
                                   (kUpperBound - kLowerBound + 1); // 9801

        std::vector<PowerFactor> vBaseDup;
        std::set<uint32_t> sPowers;

        // Step 1:
        // We need to identify bases 'a' that are powers of other
        // bases 'a', which will produce some duplicates.
        //
        // Example: base a=4=2^2.
        //    We know that for a=4 and b=2 that a^b=4^2=16 and
        //    we know that for a=2 and b=4 that a^b=2^4=16, so
        //    4^2 is a duplicate of 2^4.
        // We need to find such base that will produce some duplicate.
        // We only need to consider powers such that:
        //           a=(A^m) <= 100, for A = 2,3,4,5,6,7,8,9,10
        //                           and m = 2,3,4,5,6
        const uint32_t kLastExp[] = {0, 0, 6, 4, 3, 2, 2, 2, 2, 2, 2};
        const uint32_t kNumExp = sizeof(kLastExp) / sizeof(kLastExp[0]);

        for (uint32_t base = kLowerBound; base < kNumExp; base++)
        {
            for (uint32_t exp = kLowerBound; exp <= kLastExp[base]; exp++)
            {
                uint32_t power = EulerLib::Power(base, exp);

                // Add to set to quickly check duplicates and add to vector
                if (sPowers.find(power) == sPowers.end())
                {
                    PowerFactor factor(power, exp);
                    vBaseDup.push_back(factor);
                    sPowers.insert(power);
                }
            }
        }

        // Step 2:
        // Now find the duplicates from the list of bases we deduced.
        // We need to check for a^b such that a^b = (A^m)^b = (A^n)^b.
        // We can apply the law of exponents and the equation becomes
        // A^(m*b) = A^(n*c), so basically check m*b = n*c
        //
        // For example, let's check a=8 where 8^b = (2^3)^b, we know that
        // we can find some duplicates for powers of 2 less than 2^3, so
        // we check:
        //   (1) (2^3)^b = (2^2)^x
        //           3*b = 2*x,   where value values for x: 2 <= x <= 100,
        //             b = 2*x/3, where 2 <= b <= 66
        //        so duplicate b = {4, 6, ..., 22, 24, 26, ..., 66}
        //        and          x = {6, 9, ..., 33, 36, 39, ..., 99}
        //
        //   (2) (2^3)^b = (2^1)^y,
        //           3*b = y,     where valid values for y: 2 <= y <= 100,
        //             b = y/3,   where 2 <= b <= 33,
        //        so duplicate b = {2, 3, ..., 33}
        //        and          y = {6, 9, ..., 99}
        //
        // From this, we derived the following formula:
        //   For a^b = (A^m)^b = (A^n)^c
        //             A^(m*b) = A^(n*c)
        //                 m*b = n*c
        // Where we must check all n = {1, ..., m-1} and m is already known
        // from step 1. We will check for all c = {2, 3, ..., 100}, thus
        // finding some b such that a^b are duplicates of a lower power.
        std::set<std::pair<uint32_t, uint32_t> > duplicates;
        size_t baseDupSize = vBaseDup.size();
        uint32_t result = kMaxTerms;

        for (size_t index = 0; index < baseDupSize; index++)
        {
            uint32_t a = vBaseDup[index].m_Power;
            uint32_t m = vBaseDup[index].m_Exp;

            for (uint32_t n = 1; n < m; n++)
            {
                for (uint32_t c = kLowerBound; c <= kUpperBound; c++)
                {
                    // lhs = rhs
                    // m*b = n*c
                    uint32_t rhs = n * c;
                    uint32_t b = rhs / m;

                    // Must check that b is an integer (no remainder)
                    // and it is greater than one (at least 2).
                    if (rhs % m == 0 && b > 1)
                    {
                        duplicates.insert(std::make_pair(a, b));
                    }
                }
            }

            result -= duplicates.size();

            duplicates.clear();
        }

        SetAnswer(result);
    }

}
